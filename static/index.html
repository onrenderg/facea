<!DOCTYPE html>
<html lang="en">

<!-- C:\Program Files\Google\Chrome\Application>chrome.exe --user-data-dir="C://ChromeDevSession" --disable-web-security -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Vector Processor</title>
    <script>
        // Fetch polyfill for file:// URLs - required for face-api.js model loading in Android WebView
        (function () {
            const originalFetch = window.fetch;
            window.fetch = function (input, init) {
                let url = typeof input === 'string' ? input : (input && input.url ? input.url : null);
                if (!url) return originalFetch.call(window, input, init);

                // Convert relative URLs to file:// URLs
                if (!url.startsWith('http') && !url.startsWith('file://')) {
                    const base = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                    if (url.startsWith('./')) {
                        url = base + url.substring(2);
                    } else if (url.startsWith('/')) {
                        url = 'file://' + url;
                    } else {
                        url = base + url;
                    }
                }

                // Handle file:// URLs with XHR
                if (url.startsWith('file://')) {
                    return new Promise((resolve, reject) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', url, true);
                        xhr.responseType = 'arraybuffer';

                        xhr.onload = function () {
                            if (xhr.status === 0 || xhr.status === 200) {
                                const arrayBuffer = xhr.response;
                                const headers = new Headers();
                                headers.set('content-type', url.endsWith('.json') ? 'application/json' : 'application/octet-stream');

                                resolve({
                                    ok: true,
                                    status: 200,
                                    headers: headers,
                                    url: url,
                                    json: function () {
                                        const text = new TextDecoder().decode(arrayBuffer);
                                        return Promise.resolve(JSON.parse(text));
                                    },
                                    text: function () {
                                        return Promise.resolve(new TextDecoder().decode(arrayBuffer));
                                    },
                                    arrayBuffer: function () {
                                        return Promise.resolve(arrayBuffer);
                                    },
                                    blob: function () {
                                        return Promise.resolve(new Blob([arrayBuffer]));
                                    }
                                });
                            } else {
                                reject(new Error('XHR failed: ' + xhr.status + ' for ' + url));
                            }
                        };
                        xhr.onerror = function () {
                            reject(new Error('XHR error for ' + url));
                        };
                        xhr.send();
                    });
                }
                return originalFetch.call(window, input, init);
            };
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .config-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
        }

        .config-item label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .config-item input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .config-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.4);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .status-box {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }

        .status-box.show {
            display: block;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }

        .progress-bar.show {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .candidates-section {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        th,
        td {
            padding: 12px 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .photo-thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 6px;
            border: 2px solid #667eea;
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸ§  Face Vector Processor</h1>
        <p class="subtitle">Extract 128D face vectors using face-api.js TensorFlow models</p>

        <div class="config-section">
            <div class="config-title">API Configuration</div>
            <div class="config-grid">
                <div class="config-item">
                    <label>Centre Code</label>
                    <input type="text" id="centreCode" value="58">
                </div>
                <div class="config-item">
                    <label>Advt ID</label>
                    <input type="text" id="advtID" value="348">
                </div>
                <div class="config-item">
                    <label>Stage ID</label>
                    <input type="text" id="stageID" value="2">
                </div>
                <div class="config-item">
                    <label>Paper ID</label>
                    <input type="text" id="paperID" value="3">
                </div>
                <div class="config-item">
                    <label>State Code</label>
                    <input type="text" id="stateCode" value="2">
                </div>
                <div class="config-item">
                    <label>Org ID</label>
                    <input type="text" id="orgID" value="1">
                </div>
            </div>
        </div>

        <div class="button-group">
            <button class="btn-primary" onclick="fetchCandidates()" id="fetchBtn">
                ï¿½ Fetch Candidates
            </button>
            <button class="btn-secondary" onclick="batchConvertToVectors()" id="convertBtn" disabled>
                ðŸ§  Batch Convert to Vector
            </button>
        </div>

        <div id="statusBox" class="status-box"></div>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p id="loadingText">Processing...</p>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="candidateCount">0</div>
                <div class="stat-label">Candidates Fetched</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="vectorCount">0</div>
                <div class="stat-label">Vectors Generated</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="processedCount">0</div>
                <div class="stat-label">Processing</div>
            </div>
        </div>

        <!-- Candidates Table -->
        <div id="candidatesTable" class="candidates-section" style="display: none;">
            <h3 style="margin: 20px 0 15px; color: #333;">ðŸ“‹ Fetched Candidates</h3>
            <div class="table-container">
                <table id="candidatesList">
                    <thead>
                        <tr>
                            <th>Roll No</th>
                            <th>App No</th>
                            <th>Name</th>
                            <th>Father's Name</th>
                            <th>Category</th>
                            <th>Photo</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>


    <!-- format into table [{"RollNo":"","AppNo":"","Name":"","FatherName":"","Category":"","Photo":"","Vector":""}] -->
    <div id="logvectorTable"></div>

    <!-- Include face-api.js - Download from: https://drive.google.com/drive/folders/1JSIQtqab876Yyl5XJsesMIeg-zKGMBP- -->
    <!-- Place face-api.min.js in Resources/Raw/ folder -->
    <script src="static/js/face-api.min.js"></script>

    <script>
        let modelsLoaded = false;
        let fetchedCandidates = []; // Store fetched candidates for batch processing
        let generatedVectors = []; // Store generated vectors

        function showStatus(message, type) {
            const statusBox = document.getElementById('statusBox');
            statusBox.className = `status-box show status-${type}`;
            statusBox.textContent = message;

            setTimeout(() => {
                statusBox.classList.remove('show');
            }, 10000);
        }

        function showLoading(show, text = 'Processing...') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');

            if (show) {
                loading.classList.add('show');
                loadingText.textContent = text;
                document.getElementById('fetchBtn').disabled = true;
                document.getElementById('convertBtn').disabled = true;
            } else {
                loading.classList.remove('show');
                document.getElementById('fetchBtn').disabled = false;
                // Only enable convert button if we have candidates
                document.getElementById('convertBtn').disabled = fetchedCandidates.length === 0;
            }
        }

        function updateProgress(current, total) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');

            if (total > 0) {
                progressBar.classList.add('show');
                const percentage = (current / total) * 100;
                progressFill.style.width = percentage + '%';
            } else {
                progressBar.classList.remove('show');
            }
        }

        // Load face-api.js models (only once)
        async function loadModels() {
            if (modelsLoaded) return true;

            try {
                showStatus('Loading face detection models...', 'info');

                // Uncomment when you have face-api.js and models

                await faceapi.nets.tinyFaceDetector.loadFromUri('static/models');
                await faceapi.nets.faceLandmark68Net.loadFromUri('static/models');
                await faceapi.nets.faceRecognitionNet.loadFromUri('static/models');
                await faceapi.nets.ssdMobilenetv1.loadFromUri('static/models');


                modelsLoaded = true;
                showStatus('Models loaded successfully!', 'success');
                return true;
            } catch (error) {
                showStatus(`Model loading error: ${error.message}`, 'error');
                return false;
            }
        }

        // Convert base64 to Image object
        function loadImageFromBase64(base64String) {
            return new Promise((resolve, reject) => {
                const img = new Image();

                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));

                // Add prefix if missing
                if (!base64String.startsWith('data:image')) {
                    base64String = 'data:image/jpeg;base64,' + base64String;
                }

                img.src = base64String;
            });
        }

        // Extract face vector from image
        async function extractFaceVector(base64Image) {
            try {
                const img = await loadImageFromBase64(base64Image);

                // Use SsdMobilenetv1 for better accuracy on static images (same as HppscAttendance)
                // Lowered minConfidence to 0.4 for better flexibility in batch processing
                const detection = await faceapi
                    .detectSingleFace(img, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 }))
                    .withFaceLandmarks()
                    .withFaceDescriptor();

                if (!detection) {
                    return { success: false, error: "No face detected" };
                }

                const vector = Array.from(detection.descriptor);
                return { success: true, descriptor: vector };

            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Display candidates in table
        function displayCandidates(candidates) {
            const tableContainer = document.getElementById('candidatesTable');
            const tbody = document.querySelector('#candidatesList tbody');
            tbody.innerHTML = '';

            candidates.forEach((c, idx) => {
                const row = document.createElement('tr');

                // Build base64 image src
                let photoSrc = c.Photograph || '';
                if (photoSrc && !photoSrc.startsWith('data:image')) {
                    photoSrc = 'data:image/jpeg;base64,' + photoSrc;
                }

                row.innerHTML = `
                    <td>${c.RollNo || '-'}</td>
                    <td>${c.ApplicationNo || '-'}</td>
                    <td><strong>${c.Name || '-'}</strong></td>
                    <td>${c.FathersName || '-'}</td>
                    <td>${c.Category || '-'}</td>
                    <td>${photoSrc ? `<img src="${photoSrc}" class="photo-thumb" alt="Photo" onerror="this.src='';this.alt='No Photo'">` : 'No Photo'}</td>
                `;
                tbody.appendChild(row);
            });

            tableContainer.style.display = 'block';
        }

        // STEP 1: Fetch candidates from API
        async function fetchCandidates() {
            try {
                showLoading(true, 'Fetching candidates from API...');
                fetchedCandidates = [];
                generatedVectors = [];
                document.getElementById('vectorCount').textContent = '0';
                document.getElementById('processedCount').textContent = '0';

                const requestBody = {
                    CentreCode: document.getElementById('centreCode').value,
                    AdvtID: document.getElementById('advtID').value,
                    StageID: document.getElementById('stageID').value,
                    PaperID: document.getElementById('paperID').value,
                    StateCode: document.getElementById('stateCode').value,
                    OrgID: document.getElementById('orgID').value
                };

                const API_URL = 'http://10.146.50.37/PSCSOFT/api/Exam_Invigilator/GetCandidateListByCentre';

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.Status === 'S' && data.Data && data.Data.length > 0) {
                    fetchedCandidates = data.Data;

                    // Update candidate count
                    document.getElementById('candidateCount').textContent = fetchedCandidates.length;

                    // Display candidates in table
                    displayCandidates(fetchedCandidates);

                    showStatus(`âœ… Fetched ${fetchedCandidates.length} candidates successfully! Click "Batch Convert to Vector" to process photos.`, 'success');

                    // Enable convert button
                    document.getElementById('convertBtn').disabled = false;

                } else {
                    showStatus(data.Msg || 'No data received from API', 'error');
                    document.getElementById('candidatesTable').style.display = 'none';
                }

                showLoading(false);

            } catch (error) {
                showStatus(`âŒ Error: ${error.message}`, 'error');
                showLoading(false);
            }
        }

        // STEP 2: Batch convert photographs to vectors
        async function batchConvertToVectors() {
            if (fetchedCandidates.length === 0) {
                showStatus('No candidates to process. Fetch candidates first!', 'error');
                return;
            }

            try {
                showLoading(true, 'Loading face detection models...');

                // Load models if not already loaded
                await loadModels();

                showLoading(true, `Processing ${fetchedCandidates.length} photos...`);
                updateProgress(0, fetchedCandidates.length);

                generatedVectors = [];
                let processed = 0;
                let successCount = 0;
                let failCount = 0;

                for (const candidate of fetchedCandidates) {
                    try {
                        const photoBase64 = candidate.Photograph || '';

                        if (!photoBase64) {
                            failCount++;
                            processed++;
                            updateProgress(processed, fetchedCandidates.length);
                            document.getElementById('processedCount').textContent = `${processed}/${fetchedCandidates.length}`;
                            continue;
                        }

                        const result = await extractFaceVector(photoBase64);

                        if (result.success) {
                            generatedVectors.push({
                                RollNo: candidate.RollNo,
                                ApplicationNo: candidate.ApplicationNo,
                                Name: candidate.Name,
                                FathersName: candidate.FathersName,
                                Category: candidate.Category,
                                Photograph: photoBase64,
                                Vector: result.descriptor // Array[128]
                            });
                            successCount++;
                        } else {
                            console.error(`Failed to process ${candidate.Name}: ${result.error}`);
                            failCount++;
                        }

                        processed++;
                        updateProgress(processed, fetchedCandidates.length);
                        document.getElementById('processedCount').textContent = `${processed}/${fetchedCandidates.length}`;
                        document.getElementById('vectorCount').textContent = successCount;

                    } catch (error) {
                        console.error(`Error processing ${candidate.Name}:`, error);
                        failCount++;
                        processed++;
                    }
                }

                // Log results to console
                console.log('Generated Vectors:', generatedVectors);
                console.log('Vector Data (JSON):', JSON.stringify(generatedVectors, null, 2));
                // show in html page using .innerhtml  in table 
                // document.getElementById('logvectorTable').innerHTML = JSON.stringify(generatedVectors, null, 2);
                // inner.html table td 
                const table = document.getElementById('logvectorTable');
                table.innerHTML = '';
                generatedVectors.forEach(vector => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${vector.RollNo}</td>
                        <td>${vector.ApplicationNo}</td>
                        <td>${vector.Name}</td>
                        <td>${vector.FathersName}</td>
                        <td>${vector.Category}</td>
                        <td>${vector.Vector}</td>
                        <td>${vector.Photograph}</td>

                    `;
                    table.appendChild(row);
                });


                showLoading(false);
                updateProgress(0, 0);

                if (generatedVectors.length > 0) {
                    showStatus(`âœ… Successfully generated ${successCount} face vectors! (${failCount} failed). Check console for data.`, 'success');
                } else {
                    showStatus('âŒ No face vectors could be generated', 'error');
                }


            } catch (error) {
                showStatus(`âŒ Processing error: ${error.message}`, 'error');
                showLoading(false);
                updateProgress(0, 0);
            }
        }

        // Function to get all generated vectors (can be called from console or C#)
        window.getGeneratedVectors = function () {
            return generatedVectors;
        };

        // Initialize
        setTimeout(() => {
            showStatus('Ready! Configure parameters and click "Fetch Candidates"', 'info');
        }, 500);
    </script>
</body>

</html>